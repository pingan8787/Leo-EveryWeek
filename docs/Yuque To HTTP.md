### 1. HTTP 请求报文与响应报文格式

#### 1.1 请求报文

请求报文由**请求行**、**请求头部**和**请求正文**组成：  

* **请求行**  

格式为：   

```
请求方法 + 空格 + URL + 空格 + 协议版本 + 回车符 + 换行符
```

例如：   

```
GET www.baidu.com HTTP/1.1  
```

常见的请求方法有：GET，HEAD，PUT，POST，TRACE，OPTIONS，DELETE以及扩展方法。   

* **请求头部**    

格式为：   

```
头部字段名 + 冒号（:） + 值 + 回车符 + 换行符
```

请求头部为请求报文添加了一些附加信息，由“**名/值**”对组成，每行一对，名和值之间使用**冒号**分隔。   

并且，在**请求头部的最后会有一个空行**，表示请求头部结束，这一行必不可少。

典型的请求头部有：   

|请求头部|说明|
|---|---|
|Host|接受请求的服务器地址，可以是IP:端口号，也可以是域名|
|User-Agent|发送请求的应用程序名称|
|Connection|指定与连接相关的属性，如Connection:Keep-Alive|
|Accept-Charset|通知服务端可以发送的编码格式|
|Accept-Encoding|通知服务端可以发送的数据压缩格式|
|Accept-Language|通知服务端可以发送的语言|

* **请求正文**    

一般使用在 `POST` 方法中， `GET` 方法不存在请求正文。   
`POST` 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 `Content-Type` 和 `Content-Length` 。


#### 1.2 响应报文

响应报文由**状态行**、**响应头部**和**响应正文**组成：    


* **状态行**  

格式为：   

```
协议版本 + 空格 + 状态码 + 空格 + 状态码描述 + 回车符 + 换行符
```

状态码划分：   

100〜199的状态码是 HTTP / 1.1 向协议中引入了**信息性状态码**；  
200〜299的状态码表示**成功**；    
300〜399的状态码指**资源重定向**；    
400〜499的状态码指**客户端请求出错**；    
500〜599的状态码指**服务端出错**；  


常见的状态码：   

|状态码|说明|
|---|---|
|200|响应成功|
|302|跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别）|
|400|客户端请求有语法错误，不能被服务器识别|
|403|服务器接收到请求，但是拒绝提供服务（认证失败）|
|404|请求资源不存在|
|500|服务器内部错误|

* **响应头部**    

格式为：   

```
头部字段名 + 冒号（:） + 值 + 回车符 + 换行符
```

常见响应头部：   

|响应头部|说明|
|---|---|
|Server|服务器应用程序软件的名称和版本|
|Content-Type|响应正文的类型（是图片还是二进制字符串）|
|Content-Length|响应正文长度|
|Content-Charset|响应正文使用的编码|
|Content-Encoding|响应正文使用的数据压缩格式|
|Content-Language|响应正文使用的语言|


### 2. HTTP/1.1 有什么优缺点

#### 2.1 HTTP1.1 优点

1. 增加持久性连接

也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个TCP连接，减少了建立和关闭连接的消耗和延迟。   
```
Connection: keep-alive
```

2. 增加管道机制

增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。   

![管道](http://images.pingan8787.com/20190609http01.png)   

3. 分块传输

在 HTTP1.1版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据，很明此种方式更加优秀一些，可以节省很多等待时间。   

4. 增加 `host` 字段

此字段可以指定请求的服务器域名。   


#### 2.2 HTTP1.1 缺点

1. 此版本的网络延迟问题主要由于队头堵塞导致，虽然通过持久性连接得到改善，但是每一个请求的响应依然需要按照顺序排队，如果前面的响应处理较为耗费时间，那么同样非常耗费性能。

2. 还有此版本虽然引进了管道机制，但是当前存在诸多问题，且默认处于关闭状态。


### 3. 相比 HTTP/1.1，HTTP/2 有哪些新特性

* 多路复用

允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。

* 二进制分帧

在应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。
 
* 首部压缩

HTTP1.1 不支持 header 数据的压缩，HTTP2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

* 服务器推送

在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。

### 4. 请简述 HTTPS 工作原理

![流程](http://images.pingan8787.com/20190609http02.png)   

1. 客户端发起HTTPS请求

浏览器里面输入一个HTTPS网址，然后连接到服务端的443端口上。注意这个过程中客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单。

2. 服务端配置

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。

这套证书其实就是一对公钥和私钥，可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。

3. 传送证书

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构、过期时间等等。

4. 客户端解析证书

这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如颁发机构、过期时间等等，如果发现异常则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。

注意一下上面提到的"发现异常"。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是"发现异常"，说明该证书是伪造的。

5. 传送加密信息

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，然后客户端和服务端的通信就可以通过这个随机值来进行加密和解密了。

6. 服务端解密信息

服务端用私钥解密后，得到了客户端传过来的随机值，至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商。然后把内容通过该值进行对称加密。

7. 传输加密后的信息

这部分是服务端用随机值加密后的信息，可以在客户端被还原。

8. 客户端解密信息

客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。

### 5. HTTP 和 HTTPS 的共同点和区别

1.  https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。

2.  http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。

3.  http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4.  http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

